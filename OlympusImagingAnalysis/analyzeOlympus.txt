// This script analyzes images produced by alignOlympusImages for cell counts

// This script uses the 12-image scan layout for each array:
//    1   2   3   4  5  6
//   12  11   10  9  8  7
// Each image has 8 rows and 11 columns, except for 6 and 7 which have 9 columns

detectionThreshold = 125;

print("\\Clear");

// Determine the OS for directory pathing purposes.  Windows uses "\", while other operating systems use "/"
slash = "/";
sysType = getInfo("os.name");
if (indexOf(sysType, "Windows") != -1) {
	slash = "\\";
}

// Define this script's directory and its parent, then use these to define the output folder
scriptHome = File.getParent(getInfo("macro.filepath")) + slash;
scriptParent = File.getParent(scriptHome) + slash;
imageHome = scriptParent + "ProcessedData" + slash + "OlympusImages" + slash;
csvOutput = scriptParent + "ProcessedData" + slash + "OlympusCSVs" + slash;
File.makeDirectory(csvOutput);


// Get the list of files in the imageFolder
fileList = getFileList(imageHome);
imageList = newArray(0);
for (i = 0; i < fileList.length; i++) {
	if (indexOf(fileList[i], ".tif") >= 0) {
		imageList = Array.concat(imageList, fileList[i]);
	}
}
sortedImageList = Array.sort(imageList);


// This function takes a profile generated by getProfile, prunes values outside of a given min/max, and reports a version of the remaining array values.  This value of mean + 4*std works surprisingly well, with an average just below 125
function pruneProfile(profile, lowerlim, upperlim) {
	modProfile = newArray(0);
	for (i = 0; i < profile.length; i++) {
		if (profile[i] > lowerlim && profile[i] < upperlim) {
			modProfile = Array.concat(modProfile, profile[i]);
		}
	}
	Array.getStatistics(modProfile, min, max, mean, std);
	
	return(mean + 4*std);
}


// This function creates a set of regions of interest in ImageJ's ROI Manager for use by countCells.  These regions of interest are tailored to the well locations resulting from alignOlympusImages' rotations and crops
function roiGrid(imgNum) {
	roiManager("reset");
	pencilWidth=1;
	imgwidth = getWidth();

	x = 1;
	y = 1;
	boxwidth = 55;
	boxheight = 100;
	xspacing = 35.2;
	yspacing = 44.8;
	numRow = 8;
	numCol = 11;

	// The last two images are 8x9 wells instead of 8x11
	if (imgNum == 6 || imgNum == 7) {
		numCol = 9;
	}
	run("Clear Results");
	pencilWidth=1;


	// Draws the grid of boxes to add to the ROI Manager
	
	// For each row...
	for (i = 0; i < numRow; i++) {
		// For each column
		for (j = 0; j < numCol; j++) {
			xOffset = j * (boxwidth + xspacing);
			yOffset = i * (boxheight + yspacing);
			makeRectangle(x + xOffset, y + yOffset, boxwidth, boxheight);
			roiManager("Add");
		}
	}
	
	// Set the ROI Grid color so we can see what's going on
	roiManager("Show All");
	roiManager("Set Color", "red");
}



// This function uses the built-in Analyze Particles function to count the cells in a set of regions of interest created by roiGrid, then modifies these values based on the particles' shapes and sizes
function countCells() {
	CellArray = newArray(roiManager("count"));
	run("Set Measurements...", "area fit median redirect=None decimal=3");
	run("Clear Results");

	// For each ROI...
	for (j=0; j<roiManager("count"); j++) {
   	 	roiManager("select", j);
   	 	
   	 	// Run the built-in Analyze Particles function
		run("Analyze Particles...", "size=1-150 circularity=0.2-1.00 display");

		// Check the number of cells it "counted"
		countnumber = nResults;
		finalcount = 0;

		// Check to see if it's a clump of cells rather than just one
		if (countnumber >= 1) {
			selectWindow("Results");
			
			// For each item in the results table (from Analyze Particles)
			for (k=0; k < countnumber; k++) {
				resultcount = 1;
				
				// If it's too large to be one cell, count it as two.  The exact number isn't critical and would be too error-prone
				selectWindow("Results");
				if (getResult("Area", k) > 50) {
					resultcount = 2;
					
				// Or if it's roughly twice as long as it is wide...
				} else if (getResult("Area", k) > 50 && (getResult("Major", k)/getResult("Minor", k)) >= 1.66) {
					resultcount = 2;
				}
				
				// Otherwise it stays at 1.  Add each "particle"'s revised count to finalcount for the total number of cells in this well
				finalcount = finalcount + resultcount;
			}
			run("Clear Results");
		}
		
		// Stick that number into CellArray for later use
		CellArray[j] = finalcount;
	}

	// Populate the Results window with the calculated cell count values
	for (j=0; j<CellArray.length; j++) {
		setResult("Count", j, CellArray[j]);
	}
}


// For each image on the chip...
for (i = 0; i < sortedImageList.length; i++) {
	open(imageHome + sortedImageList[i]);
	
	// Draw the ROI Grid
	imgNum = i % 12 + 1;
	roiGrid(imgNum);
	
	imgHeight = getHeight();
	
	// Get the profile of a line midway through the middle column and use this to set a threshold for cell detection
	makeLine(480, 0, 480, imgHeight);
	imgProfile = getProfile();
	
	// The minimum value is below the background fluorescence of a well to remove non-well input to the threshold calculation.  The maximum value is above the background well fluorescence in order to remove cell input to the threshold calculation
	bgProfileMean = pruneProfile(imgProfile, 65, 115);
	setThreshold(bgProfileMean, 65535);
	
	// Call the counting function
	countCells();
	
	// Save the Results to a CSV
	savename = split(sortedImageList[i], ".");
	saveAs("Results", csvOutput +  savename[0] + ".csv");
	
	// Clean up in preparation for the next image
	selectWindow(sortedImageList[i]);
	close();
	run("Clear Results");
}